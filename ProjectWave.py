# -*- coding: utf-8 -*-
"""AvaliacaoOndas.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1s692q6fhnDndXiT6c85D8U6nbm0YfDiI

#Script produzido para cﾃ｡lculo de onda de projeto para dimensionar obras costeiras a partir de dados de ondas (ondﾃｳgrafos ou modelos).

A definiﾃｧﾃ｣o de onda de projeto aqui usa o mﾃｩtodo tradicional baseado no perﾃｭodo de retorno de um EE.
"""

## Seﾃｧﾃ｣o de imports
import pandas as pd
import numpy as np
from google.colab import drive
from numpy.core.fromnumeric import mean
import matplotlib.pyplot as plt
import seaborn as sns 
import scipy as sp
import math
!pip install reliability
import reliability

"""# 1 - Organizaﾃｧﾃ｣o dos dados"""

## CARREGAMENTO DOS DADOS DE ONDA
'''
Vocﾃｪ precisarﾃ｡ acessar seu drive, mudar o diretﾃｳrio e nome do arquivo
Importante:  arquvio deve conter 3 colunas contendo (Hs, Tp, Dp) nesta ordem e com cabeﾃｧalho
'''
# mounting your google drive in the colab environment
drive.mount('/content/drive')

dframe = pd.read_csv('/content/drive/My Drive/Intertidal_Zones/Ondas/Ondas.csv',
                     header = 0,
                      sep = ';',
                     #usecols = ['Hs','Tp','Dp']
                      )
#print (dframe)

# ORGANIZAﾃﾃグ DAS ALTURAS
H_ordenado = sorted(dframe['Hs'])
#print(H_ordenado)

# Cﾃ´CULO DE Hs E DEFINIﾃﾃグ DE LIMIAR
print('tamanho do dado:', len(H_ordenado)//3)
C = len(H_ordenado)
Hs = mean(H_ordenado[:C])
print('Hs =', Hs)

"""# 2 - TRATAMENTO DOS DADOS"""

plt.plot(dframe['Hs'])
plt.title('Alturas de ondas')
plt.axhline(y = Hs, color = 'r', linestyle = '-') 
plt.show()

"""Como podem aparecer mais de um valor superior ao limiar em um mesmo perﾃｭodo, poderiam ser considerados referentes a uma mesma tempestade. 
Entﾃ｣o, para se considerar a independﾃｪncia dos eventos, foi estipulado um perﾃｭodo de X dias (vocﾃｪ pode modificar de acordo com sua regiﾃ｣o)
"""

# CONSIDERAR INDEPENDENCIA TEMPORAL --> 7 DIAS?
# a cada 7 dias, pegar os valores maiores que Hs
extremo = np.arange(len(dframe['Hs']),dtype=float)
extremo_plt = np.empty((len( dframe['Hs'] ))) # essa aqui ﾃｩ sﾃｳ pra fazer um plot
extremo_plt.fill(np.nan)
Hss_dep=[]
for i in range(len(dframe['Hs'])): # iteraﾃｧﾃ｣o para identificar se o evento ﾃｩ maior que Hs ou nﾃ｣o
  #print(dframe['Hs'].iloc[i])
  if np.isnan(dframe['Hs'].iloc[i]):
    extremo = dframe['Hs'][i]
  elif dframe['Hs'].iloc[i]<(Hs):
    extremo[i]=0 # quanto 'extremo' for igual a zero, o evento nﾃ｣o ﾃｩ extremo
  elif dframe['Hs'].iloc[i]>=(Hs):
    extremo[i]=1 # quanto 'extremo' for igual a 1, o evento ﾃｩ extremo
    extremo_plt[i] = dframe['Hs'].iloc[i]
    Hss_dep.append(dframe['Hs'][i])

extremo_independete = np.zeros(np.shape(Hss_dep),dtype=float) # Criando o vetor que vai indicar a ocorrﾃｪncia do evento independente e o nﾃｺmero do evento
out=[] # lista auxiliar da funﾃｧﾃ｣o
counta=1 # contador para auxiliar a funﾃｧﾃ｣o
for i in range(1,len(extremo)): # esta iteraﾃｧﾃ｣o vai criar um vetor que identifica o inicio e o fim dos eventos extremos, eventos acima do limiar
  if extremo[i]==1:  
    out.append([i-counta-1,i-1])
    counta+=1 # o out ﾃｩ a lista que identifica o inicio e o fim dos eventos acima do limiar-> out[[inicio, fim],[incio,fim]]

count=0
Hss=[]
#print(len(out))
for i in range(1,len(out)): # esta iteraﾃｧﾃ｣o vai verificar se o inﾃｭcio do evento i+1 tem intervalo de 7 dias do fim do evento i
  if out[i][1]-out[i-1][0]>=(7*24*3):
    count+=1 # (7*24/8) -> se seus dados tem frequencia amostral de 30', isto ﾃｩ igual ao periodo de 7 dias 
    np.put(extremo_independete, # o 'extremo_independete' ﾃｩ pra ser o seu resultado final. extremo_independete>1 indica ocorrencia de evento
           count,
           np.arange(out[i][1],out[i-1][0])
           )
    Hss.append(Hss_dep[i])
    
print('O nﾃｺmero de eventos extremos (H(t)>Hs) na sﾃｩries temporal ﾃｩ: ', count) #nﾃｺmero de eventos independentes
print('   ')
plt.plot(dframe['Hs'])
plt.plot(extremo_plt)
plt.title('Alturas de ondas')
plt.axhline(y = Hs, color = 'r', linestyle = '-') 
#plt.legend()
plt.show()
#print((Hss))
# GERAR TABELA DE DISTRIBUIﾃﾃグ POR CLASSES

"""# 3 - PROBABILIDADES"""

# FORMA MANUAL, AINDA Nﾃグ CONCLUﾃ好A

Hss_ordenado = sorted(Hss)
at = np.max(Hss_ordenado) - np.min(Hss_ordenado)

h=0.25
frequencias = []

# Menor valor da sﾃｩrie
menor = round(np.min(Hss_ordenado),1)

# Menor valor somado a amplitude
menor_amp = round(menor+h,1)

valor = menor
while valor < np.max(Hss_ordenado):
    frequencias.append('{} - {}'.format(round(valor,1),round(valor+h,1)))
    valor += h

freq_abs = pd.qcut(Hss_ordenado,len(frequencias),labels=frequencias) # Discretizaﾃｧﾃ｣o dos valores em k faixas, rotuladas pela lista criada anteriormente
classes = [1.3, 1.6, 1.8, 2.0, 2.3, 2.6, 2.8, 3.0, 3.3, 3.6, 3.8, 4.0, 4.3, 4.6, 4.8, 5.0]
classes_m = [1.45, 1.7, 1.9, 2.15, 2.45, 2.7, 2.9, 3.15, 3.45, 3.7, 3.9, 4.15, 4.45, 4.7, 4.9]

frequencia = pd.value_counts(pd.cut(x = Hss_ordenado, bins = classes, labels=frequencias, include_lowest = True))
percent = pd.value_counts(pd.cut(x = Hss_ordenado, bins = classes, labels = frequencias, include_lowest = True), normalize = True )

probab_classes = pd.DataFrame({'Frequencia': frequencia, 'Porcentagem': percent})
probab_classes

probab_classes['Frequencia acumluada'] = pd.DataFrame.cumsum(probab_classes['Frequencia'])
soma = sum(probab_classes['Frequencia'])
probab_classes['P'] = probab_classes['Frequencia acumluada']/soma
probab_classes['Q'] = 1- probab_classes['P']

probab_classes['Probabilidade Excedencia'] = -(np.log(probab_classes['Q']))

# NS = (EE por ano, em mﾃｩdia)
NS = len(Hss)/5 # perﾃｭodo em anos dos dados 
Qs = probab_classes['Probabilidade Excedencia']*NS
#plt.subplot(121)
plt.title('Probabilidade de Excedﾃｪncia Anual')
plt.scatter(Qs,classes_m, marker='^', color = 'black')

Qs = Qs.iloc[:-2] 
classes_2 = [1.45, 1.7, 1.9, 2.15, 2.45, 2.7, 2.9, 3.15, 3.45, 3.7, 3.9, 4.15, 4.45]

a, b = np.polyfit(Qs,classes_2, 1) #find line of best fit
plt.plot(Qs, a*Qs+b) #add line of best fit to plot

# VISUALIZAR DISTRIBUIﾃﾃグ DE WEIBULL
'''
from reliability.Probability_plotting import Weibull_probability_plot, plot_points, plotting_positions,Exponential_probability_plot, Exponential_probability_plot_Weibull_Scale
from reliability.Fitters import Fit_Weibull_2P
plt.subplot(122)
Weibull_probability_plot(failures=Hss) #cumulative distribution function
fit = Fit_Weibull_2P(failures=Hss)
plot_points(failures=Hss, color='black', marker='^', s=50)
plt.legend()
plt.show()
'''

"""# 4 - ONDA DE PROJETO"""

# 製蔵蔵 = 竏挺攝ｴ ln(槍) + 牲
# da distribuiﾃｧﾃ｣o de weibul
# A = 1.77
# B = 6.79

# AJUSTAR UMA RETA AX+B COM OS VALORES ENCONTRADOS
A = a
B = b
y = (A*Qs)+B #Qs = -log(Q)

plt.grid(linestyle = '--')
plt.plot(Qs,y) 
plt.title('Probabilidade de Excedﾃｪncia Anual')
plt.xlabel('Probabilidade de Excedﾃｪncia Anual')
plt.ylabel('Hss (m)')

# EXTENDE-SE ESSA RETA PARA O TEMPO DE RETORNO DA ONDA DESEJADO
from math import log
# TR = VIDA ﾃ啜IL DA OBRA = 20 anos (3*tamanho das observaﾃｧﾃｵes)
# Calculo de acordo com equaﾃｧﾃ｣o
X = -log((1/20)/NS)

Hproj = A*X + B
print('   ')
print("Altura da onda de projeto:", Hproj)
print('   ')