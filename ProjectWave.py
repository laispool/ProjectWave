# -*- coding: utf-8 -*-
"""AvaliacaoOndas.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1s692q6fhnDndXiT6c85D8U6nbm0YfDiI

#Script produzido para cálculo de onda de projeto para dimensionar obras costeiras a partir de dados de ondas (ondógrafos ou modelos).

A definição de onda de projeto aqui usa o método tradicional baseado no período de retorno de um EE.
"""

## Seção de imports
import pandas as pd
import numpy as np
from google.colab import drive
from numpy.core.fromnumeric import mean
import matplotlib.pyplot as plt
import seaborn as sns 
import scipy as sp
import math
!pip install reliability
import reliability

"""# 1 - Organização dos dados"""

## CARREGAMENTO DOS DADOS DE ONDA
'''
Você precisará acessar seu drive, mudar o diretório e nome do arquivo
Importante:  arquvio deve conter 3 colunas contendo (Hs, Tp, Dp) nesta ordem e com cabeçalho
'''
# mounting your google drive in the colab environment
drive.mount('/content/drive')

dframe = pd.read_csv('/content/drive/My Drive/Intertidal_Zones/Ondas/Ondas.csv',
                     header = 0,
                      sep = ';',
                     #usecols = ['Hs','Tp','Dp']
                      )
#print (dframe)

# ORGANIZAÇÃO DAS ALTURAS
H_ordenado = sorted(dframe['Hs'])
#print(H_ordenado)

# CÁLCULO DE Hs E DEFINIÇÃO DE LIMIAR
print('tamanho do dado:', len(H_ordenado)//3)
C = len(H_ordenado)
Hs = mean(H_ordenado[:C])
print('Hs =', Hs)

"""# 2 - TRATAMENTO DOS DADOS"""

plt.plot(dframe['Hs'])
plt.title('Alturas de ondas')
plt.axhline(y = Hs, color = 'r', linestyle = '-') 
plt.show()

"""Como podem aparecer mais de um valor superior ao limiar em um mesmo período, poderiam ser considerados referentes a uma mesma tempestade. 
Então, para se considerar a independência dos eventos, foi estipulado um período de X dias (você pode modificar de acordo com sua região)
"""

# CONSIDERAR INDEPENDENCIA TEMPORAL --> 7 DIAS?
# a cada 7 dias, pegar os valores maiores que Hs
extremo = np.arange(len(dframe['Hs']),dtype=float)
extremo_plt = np.empty((len( dframe['Hs'] ))) # essa aqui é só pra fazer um plot
extremo_plt.fill(np.nan)
Hss_dep=[]
for i in range(len(dframe['Hs'])): # iteração para identificar se o evento é maior que Hs ou não
  #print(dframe['Hs'].iloc[i])
  if np.isnan(dframe['Hs'].iloc[i]):
    extremo = dframe['Hs'][i]
  elif dframe['Hs'].iloc[i]<(Hs):
    extremo[i]=0 # quanto 'extremo' for igual a zero, o evento não é extremo
  elif dframe['Hs'].iloc[i]>=(Hs):
    extremo[i]=1 # quanto 'extremo' for igual a 1, o evento é extremo
    extremo_plt[i] = dframe['Hs'].iloc[i]
    Hss_dep.append(dframe['Hs'][i])

extremo_independete = np.zeros(np.shape(Hss_dep),dtype=float) # Criando o vetor que vai indicar a ocorrência do evento independente e o número do evento
out=[] # lista auxiliar da função
counta=1 # contador para auxiliar a função
for i in range(1,len(extremo)): # esta iteração vai criar um vetor que identifica o inicio e o fim dos eventos extremos, eventos acima do limiar
  if extremo[i]==1:  
    out.append([i-counta-1,i-1])
    counta+=1 # o out é a lista que identifica o inicio e o fim dos eventos acima do limiar-> out[[inicio, fim],[incio,fim]]

count=0
Hss=[]
#print(len(out))
for i in range(1,len(out)): # esta iteração vai verificar se o início do evento i+1 tem intervalo de 7 dias do fim do evento i
  if out[i][1]-out[i-1][0]>=(7*24*3):
    count+=1 # (7*24/8) -> se seus dados tem frequencia amostral de 30', isto é igual ao periodo de 7 dias 
    np.put(extremo_independete, # o 'extremo_independete' é pra ser o seu resultado final. extremo_independete>1 indica ocorrencia de evento
           count,
           np.arange(out[i][1],out[i-1][0])
           )
    Hss.append(Hss_dep[i])
    
print('O número de eventos extremos (H(t)>Hs) na séries temporal é: ', count) #número de eventos independentes
print('   ')
plt.plot(dframe['Hs'])
plt.plot(extremo_plt)
plt.title('Alturas de ondas')
plt.axhline(y = Hs, color = 'r', linestyle = '-') 
#plt.legend()
plt.show()
#print((Hss))
# GERAR TABELA DE DISTRIBUIÇÃO POR CLASSES

"""# 3 - PROBABILIDADES"""

# FORMA MANUAL, AINDA NÃO CONCLUÍDA

Hss_ordenado = sorted(Hss)
at = np.max(Hss_ordenado) - np.min(Hss_ordenado)

h=0.25
frequencias = []

# Menor valor da série
menor = round(np.min(Hss_ordenado),1)

# Menor valor somado a amplitude
menor_amp = round(menor+h,1)

valor = menor
while valor < np.max(Hss_ordenado):
    frequencias.append('{} - {}'.format(round(valor,1),round(valor+h,1)))
    valor += h

freq_abs = pd.qcut(Hss_ordenado,len(frequencias),labels=frequencias) # Discretização dos valores em k faixas, rotuladas pela lista criada anteriormente
classes = [1.3, 1.6, 1.8, 2.0, 2.3, 2.6, 2.8, 3.0, 3.3, 3.6, 3.8, 4.0, 4.3, 4.6, 4.8, 5.0]
classes_m = [1.45, 1.7, 1.9, 2.15, 2.45, 2.7, 2.9, 3.15, 3.45, 3.7, 3.9, 4.15, 4.45, 4.7, 4.9]

frequencia = pd.value_counts(pd.cut(x = Hss_ordenado, bins = classes, labels=frequencias, include_lowest = True))
percent = pd.value_counts(pd.cut(x = Hss_ordenado, bins = classes, labels = frequencias, include_lowest = True), normalize = True )

probab_classes = pd.DataFrame({'Frequencia': frequencia, 'Porcentagem': percent})
probab_classes

probab_classes['Frequencia acumluada'] = pd.DataFrame.cumsum(probab_classes['Frequencia'])
soma = sum(probab_classes['Frequencia'])
probab_classes['P'] = probab_classes['Frequencia acumluada']/soma
probab_classes['Q'] = 1- probab_classes['P']

probab_classes['Probabilidade Excedencia'] = -(np.log(probab_classes['Q']))

# NS = (EE por ano, em média)
NS = len(Hss)/5 # período em anos dos dados 
Qs = probab_classes['Probabilidade Excedencia']*NS
#plt.subplot(121)
plt.title('Probabilidade de Excedência Anual')
plt.scatter(Qs,classes_m, marker='^', color = 'black')

Qs = Qs.iloc[:-2] 
classes_2 = [1.45, 1.7, 1.9, 2.15, 2.45, 2.7, 2.9, 3.15, 3.45, 3.7, 3.9, 4.15, 4.45]

a, b = np.polyfit(Qs,classes_2, 1) #find line of best fit
plt.plot(Qs, a*Qs+b) #add line of best fit to plot

# VISUALIZAR DISTRIBUIÇÃO DE WEIBULL
'''
from reliability.Probability_plotting import Weibull_probability_plot, plot_points, plotting_positions,Exponential_probability_plot, Exponential_probability_plot_Weibull_Scale
from reliability.Fitters import Fit_Weibull_2P
plt.subplot(122)
Weibull_probability_plot(failures=Hss) #cumulative distribution function
fit = Fit_Weibull_2P(failures=Hss)
plot_points(failures=Hss, color='black', marker='^', s=50)
plt.legend()
plt.show()
'''

"""# 4 - ONDA DE PROJETO"""

# 𝐻𝑠𝑠 = −𝐴 ln(𝑄) + 𝐵
# da distribuição de weibul
# A = 1.77
# B = 6.79

# AJUSTAR UMA RETA AX+B COM OS VALORES ENCONTRADOS
A = a
B = b
y = (A*Qs)+B #Qs = -log(Q)

plt.grid(linestyle = '--')
plt.plot(Qs,y) 
plt.title('Probabilidade de Excedência Anual')
plt.xlabel('Probabilidade de Excedência Anual')
plt.ylabel('Hss (m)')

# EXTENDE-SE ESSA RETA PARA O TEMPO DE RETORNO DA ONDA DESEJADO
from math import log
# TR = VIDA ÚTIL DA OBRA = 20 anos (3*tamanho das observações)
# Calculo de acordo com equação
X = -log((1/20)/NS)

Hproj = A*X + B
print('   ')
print("Altura da onda de projeto:", Hproj)
print('   ')